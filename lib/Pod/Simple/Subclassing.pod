
=head1 NAME

Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass

=head1 SYNOPSIS

  package Pod::SomeFormatter;
  use Pod::Simple;
  @ISA = qw(Pod::Simple);
  $VERSION = '1.01';
  use strict;

  sub _handle_element_start {
    my($parser, $element_name, $attr_hash_r) = @_;
    ...
  }

  sub _handle_element_end {
    my($parser, $element_name) = @_;
    ...
  }

  sub _handle_text {
    my($parser, $text) = @_;
    ...
  }
  1;

=head1 DESCRIPTION

This document is about using Pod::Simple to write a Pod processor,
generally a Pod formatter. If you just want to know about using an
existing Pod formatter, instead see its documentation and see also the
docs in L<Pod::Simple>.

The zeroeth step in writing a Pod formatter is to make sure that there
isn't already a decent one in CPAN. See L<http://search.cpan.org/>, and
run a search on the name of the format you want to render to. Also
consider joining the Pod People list
L<http://lists.perl.org/showlist.cgi?name=pod-people> and asking whether
anyone has a formatter for that format -- maybe someone cobbled one
together but just hasn't released it.

The first step in writing a Pod processor is to read L<perlpodspec>,
which contains notes information on writing a Pod parser (which has been
largely taken care of by Pod::Simple), but also a lot of requirements
and recommendations for writing a formatter.

The second step is to actually learn the format you're planning to
format to -- or at least as much as you need to know to represent Pod,
which probably isn't much.

The third step is to pick which of Pod::Simple's interfaces you want to
use -- the basic interface via Pod::Simple or L<Pod::Simple::Methody> is
event-based, sort of like L<HTML::Parser>'s interface, or sort of like
L<XML::Parser>'s "Handlers" interface), but L<Pod::Simple::PullParser>
provides a token-stream interface, sort of like L<HTML::TokeParser>'s
interface; L<Pod::Simple::SimpleTree> provides a simple tree interface,
rather like XML::Parser's "Tree" interface. Users familiar with
XML-handling will find one of these styles relatively familiar; but if
you would be even more at home with XML, there are classes that produce
an XML representation of the Pod stream, notably
L<Pod::Simple::XMLOutStream>; you can feed the output of such a class to
whatever XML parsing system you are most at home with.

The last step is to write your code based on how the events (or tokens,
or tree-nodes, or the XML, or however you're parsing) will map to
constructs in the output format. Also sure to consider how to escape
text nodes containing arbitrary text, and also what to do with text
nodes that represent preformatted text (from verbatim sections).



=head1 Events

TODO intro... mention that events are supplied for implicits, like for
missing closures.


=over

=item C<< $parser->_handle_element_start( I<element_name>, I<attr_hashref> ) >>

=item C<< $parser->_handle_element_end( I<element_name>  ) >>

=item C<< $parser->_handle_text(  I<text_string>  ) >>

=back

TODO describe

=over

=item events with an element_name of Document

TODO...

=item events with an element_name of Para

TODO...

=item events with an element_name of B, C, F, or I.

TODO...

=item events with an element_name of S

TODO...

=item events with an element_name of X

TODO...

=item events with an element_name of L

TODO...

=item events with an element_name of E or Z

TODO...

=item events with an element_name of Verbatim

TODO...

=item events with an element_name of head1 .. head4

TODO...

=item events with an element_name of over-bullet

TODO...

=item events with an element_name of over-number

TODO...

=item events with an element_name of over-text

TODO...

=item events with an element_name of over-block

TODO...

=item events with an element_name of item-bullet

TODO...

=item events with an element_name of item-number

TODO...

=item events with an element_name of item-text

TODO...

=item events with an element_name of for

TODO...

=item events with an element_name of Data

TODO...

=back



=head1 More Pod::Simple Methods

Pod::Simple provides a lot of methods that aren't generally interesting
to the end user of an existing Pod formatter, but some of which you
might find useful in writing a Pod formatter. They are listed below. The
first several methods (the accept_* methods) are for declaring the
capabilites of your parser, notably what C<=for I<targetname>> sections
it's interested in, what extra NE<lt>...E<gt> codes it accepts beyond
the ones described in the I<perlpod>.

=over

=item C<< $parser->accept_targets( I<SOMEVALUE> ) >>

As the parser sees sections like:

    =for html  <img src="fig1.jpg">

or

    =begin html

      <img src="fig1.jpg">

    =end html

...the parser will ignore these sections unless your subclass has
specified that it wants to see sections targetted to "html" (or whatever
the formatter name is).

If you want to process all sections, even if they're not targetted for you,
call this before you start parsing:

  $parser->accept_targets('*');

=item C<< $parser->accept_targets_as_text(  I<SOMEVALUE>  ) >>

This is like accept_targets, except that it specifies also that the
content of sections for this target should be treated as Pod text even
if the target name in "=for I<targetname>" doesn't start with a ":".

At time of writing, I don't think you'll need to use this.


=item C<< $parser->accept_codes( I<Codename>, I<Codename>...  ) >>

This tells the parser that you accept additional formatting codes,
beyond just the standard ones (I B C L F S X, plus the two weird ones
you don't actually see in the parse tree, Z and E). For example, to also
accept codes "N", "R", and "W":

    $parser->accept_codes( qw( N R W ) );

B<TODO: document how this interacts with =extend, and long element names>


=item C<< $parser->accept_directive_as_data( I<directive_name> ) >>

=item C<< $parser->accept_directive_as_verbatim( I<directive_name> ) >>

=item C<< $parser->accept_directive_as_processed( I<directive_name> ) >>

In the unlikely situation that you need to tell the parser that you will
accept additional directives ("=foo" things), you need to first set the
parset to treat its content as data (i.e., not really processed at
all), or as verbatim (mostly just expanding tabs), or as processed text
(parsing formatting codes like BE<lt>...E<gt>).

For example, to accept a new directive "=method", you'd presumably
use:

    $parser->accept_directive_as_processed("method");

so that you could have Pod lines like:

    =method I<$whatever> thing B<um>

Making up your own directives breaks compatibility with other Pod
formatters, in a way that using "=for I<target> ..." lines doesn't;
however, you may find this useful if you're making a Pod superset
format where you don't need to worry about compatibility.


=item C<< $parser->nbsp_for_S(I<VALUE>); >>

Setting this attribute to a true value (and by default it is false) will
take "SE<lt>...E<gt>" sequences to sequences of words separated by
C<\xA0> (non-breaking space) characters. For example, it will take this:

    I like S<Dutch apple pie>, don't you?

and treat it as if it were:

    I like DutchE<nbsp>appleE<nbsp>pie, don't you?

This is handy for output formats that don't have anything quite like an
"SE<lt>...E<gt>" code, but which do have a code for non-breaking space.

There is currently no method for going the other way; but I can
probably provide one upon request.


=item C<< $parser->version_report() >>

This returns a string reporting the $VERSION value from your module (and
its classname) as well as the $VERSION value of Pod::Simple.  Note that
L<perlpodspec> requires output formats to (wherever possible) note
this detail in a comment in the output format.  For example, for
some kind of SGML output format:

    print OUT "<!-- \n", $parser->version_report, "\n -->";


=item C<< $parser->pod_para_count() >>

This returns the count of Pod paragraphs seen so far.


=item C<< $parser->line_count() >>

This is the current line number being parsed. But you might find the
"line_number" event attribute more accurate, when it is present.


=item C<< $parser->nix_X_codes(  I<SOMEVALUE>  ) >>

This attribute, when set to a true value (and it is false by default)
ignores any "XE<lt>...E<gt>" sequences in the document being parsed.
Many formats don't actually use the content of these codes, so have
no reason to process them.


=item C<< $parser->merge_text(  I<SOMEVALUE>  ) >>

This attribute, when set to a true value (and it is false by default)
makes sure that only one event (or token, or node) will be created
for any single contiguous sequence of text.  For example, consider
this somewhat contrived example:

    I just LOVE Z<>hotE<32>apple pie!

When that is parsed and events are about to be called on it, it may
actually seem to be four different text events, one right after another:
one event for "I just LOVE ", one for "hot", one for " ", and one for
"apple pie!". But if you have merge_text on, then you're guaranteed
that it will be fired as one text event:  "I just LOVE hot apple pie!".


=item C<< $parser->code_handler(  I<CODE_REF>  ) >>

This specifies code that should be called when a code line is seen
(i.e., a line outside of the Pod).  Normally this is undef, meaning
that no code should be called.  If you provide a routine, it should
start out like this:

    sub get_code_line {  # or whatever you'll call it
      my($line, $line_number, $parser) = @_;
      ...
    }

Note, however, that sometimes the Pod events aren't processed in exactly
the same order as the code lines are -- i.e., if you have a file with
Pod, then code, then more Pod, sometimes the code will be processed (via
whatever you have code_handler call) before the all of the preceding Pod
has been processed.


=item C<< $parser->cut_handler(  I<CODE_REF>  ) >>

This is just like the code_handler attribute, except that it's for
"=cut" lines, not code lines. The same caveats apply. "=cut" lines are
unlikely to be interesting, but this is included for completeness.


=item C<< $parser->whine( I<linenumber>, I<complaint string> ) >>

This notes a problem in the Pod, which will be reported to in the "Pod
Errors" section of the document and/or send to STDERR, depending on the
values of the attributes C<no_whining>, C<no_errata_section>, and
C<complain_stderr>.

=item C<< $parser->scream( I<linenumber>, I<complaint string> ) >>

This notes an error like C<whine> does, except that it is not
suppressable with C<no_whining>. This should be used only for very
serious errors.


=item C<< $parser->source_dead(1) >>

This aborts parsing of the current document, by switching on the flag
that indicates that EOF has been seen.  In particularly drastic cases,
you might want to do this.  It's rather nicer than just calling
C<die>!

=item C<< $parser->hide_line_numbers( I<SOMEVALUE> ) >>

Some subclasses that indescriminately dump event attributes (well,
except for ones beginning with "~") can use this object attribute for
refraining to dump the "start_line" attribute.

=back


=head1 SEE ALSO

L<Pod::Simple> -- event-based Pod-parsing framework

L<Pod::Simple::Methody> -- like Pod::Simple, but each sort of event
calls its own method (like C<start_head3>)

L<Pod::Simple::PullParser> -- a Pod-parsing framework like Pod::Simple,
but with a token-stream interface

L<Pod::Simple::SimpleTree> -- a Pod-parsing framework like Pod::Simple,
but with a tree interface

L<Pod::Simple::Checker> -- a simple Pod::Simple subclass that reads
documents, and then makes a plaintext report of any errors found in the
document

L<Pod::Simple::DumpAsXML> -- for dumping Pod documents as tidily
indented XML, showing each event on its own line

L<Pod::Simple::XMLOutStream> -- dumps a Pod document as XML (without
introducing extra whitespace as Pod::Simple::DumpAsXML does).

L<Pod::Simple::DumpAsText> -- for dumping Pod documents as tidily
indented text, showing each event on its own line

L<Pod::Simple::LinkSection> -- class for objects representing the values
of the TODO and TODO attributes of LE<lt>...E<gt> elements

L<Pod::Escapes> -- the module the Pod::Simple uses for evaluating
EE<lt>...E<gt> content

L<Pod::Simple::Text> -- a simple plaintext formatter for Pod

L<Pod::Simple::TextContent> -- like Pod::Simple::Text, but
makes no effort for indent or wrap the text being formatted

L<perlpod|perlpod>

L<perlpodspec|perlpodspec>

L<perldoc>


=head1 COPYRIGHT AND DISCLAIMERS

Copyright (c) 2002 Sean M. Burke.  All rights reserved.

This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

=head1 AUTHOR

Sean M. Burke C<sburke@cpan.org>


=for notes
Hm, my old podchecker version (1.2) says:
 *** WARNING: node 'http://search.cpan.org/' contains non-escaped | or / at line 38 in file Subclassing.pod
 *** WARNING: node 'http://lists.perl.org/showlist.cgi?name=pod-people' contains non-escaped | or / at line 41 in file Subclassing.pod
Yes, L<...> is hard.


=cut


